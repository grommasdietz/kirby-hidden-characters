@font-face {
  font-display: swap;
  font-family: "hidden-characters";
  font-style: normal;
  font-weight: normal;
  src: url("/media/plugins/grommasdietz/hidden-characters/fonts/hidden-characters.woff2")
    format("woff2");
  unicode-range: U+0020, U+00A0, U+2000-200A, U+202F, U+205F, U+E000, U+E001,
    U+E002, U+E003;
}

/* --- 1. Base Setup --- */

.k-string-input.k-text-input,
.k-textarea-input-native,
.k-writer-input .ProseMirror {
  // Prevent ProseMirror from collapsing whitespace.
  // This is crucial for the hidden characters overlay to work correctly in some edge cases
  // and ensures that spaces are rendered inside the field.
  word-break: normal !important;
  white-space: break-spaces !important;
}

// overwrite default width of max-content to avoid glitches.
.k-block-figure-caption .k-writer {
  width: 100%;
}

// The .k-input-element is the direct parent of text/textarea inputs.
// It needs a `position` context for our absolute overlay to work correctly.
.k-input-element {
  position: relative;
}

.gd-hidden-characters {
  /* --- 2. Base Overlay Setup --- */

  // Position the overlay to perfectly cover its sibling input element.
  position: absolute;
  inset: 0;
  z-index: 1; // Ensure overlay is on top of the input.

  // Make the overlay non-interactive and initially invisible.
  pointer-events: none;
  contain: content;
  opacity: 0;
  color: transparent; // Hide all regular text within the overlay.
  height: 100%;
  width: 100%;

  // Ensure spaces and newlines are rendered, not collapsed by the browser.
  // This is critical for making space characters have a visible width.
  // white-space: pre-wrap;
  // word-wrap: break-word;

  /* --- 3. Element-Specific Style Adaptations --- */

  // Use the `data-tag` (set by JS) to mimic styles Kirby applies to native elements,
  // preventing layout shifts between the real input and the overlay.
  &[data-tag="textarea"] {
    line-height: 1.5;
    white-space-collapse: preserve;
    text-wrap-mode: wrap;
  }

  &:where([data-tag="textarea"], [data-tag="input"]) {
    font-variant-numeric: tabular-nums;
    line-height: normal;
  }

  &[data-tag="input"] {
    -webkit-rtl-ordering: logical;
  }

  [data-empty="true"] :focus + & > p:first-child > break:first-child::before {
    display: none; // Hide the very first marker when the input is empty and focused.
  }

  // Ensure transparent color for captions in block figures.
  .k-block-figure-caption .k-writer & {
    color: transparent !important;
  }

  /* --- 4. Activation Trigger --- */

  // Show the overlay when the preceding sibling element has focus.
  // This works because the JS inserts the overlay directly after the input.

  :focus + & {
    opacity: 0.4;
  }

  /* --- 5. Character Rendering --- */

  // Ensure any text inside our custom tags (e.g., the space in <space> </space>)
  // inherits the `color: transparent` from the overlay. This rule excludes
  // the pseudo-elements that are meant to be visible.
  *:not(:is(p::after, space::before, break::before, shy::before)) {
    color: inherit;
  }

  // General style for all our character indicator pseudo-elements.
  ::before,
  ::after {
    color: var(--color-text);
    font-family: "hidden-characters"; // Use the custom icon font.
    font-weight: normal;
    width: max-content;

    .k-block-figure-caption .k-writer & {
      // switch to the background color of the caption
      // due to default mix-blend-mode exclusion of parent.
      color: var(--color-background) !important;
    }
  }

  // For writer fields: Style the paragraph end markers.
  p::after {
    bottom: 0;
    display: inline-block;
    height: 0;
    position: relative;
    width: 0;
  }

  // Specific rules for ProseMirror's handling of trailing breaks.
  p:has(.ProseMirror-trailingBreak):after {
    margin-top: -1.5em;
    position: absolute;
  }

  p:first-child:last-child:has(.ProseMirror-trailingBreak):after {
    content: "";
  }

  // --- Base setup for all custom elements ---
  // These styles are shared by <break>, <space>, and <shy> to ensure they
  // can correctly host and align their visible pseudo-elements without
  // disrupting the vertical flow of the text.
  break,
  space,
  shy {
    // Establishes a positioning context. This is essential for the ::before
    // pseudo-element, which is absolutely positioned to overlay the symbol.
    position: relative;

    // Aligns the element's box with the text's baseline. This prevents the
    // element from altering the line height, which is critical for keeping
    // the overlay perfectly in sync with the underlying text.
    vertical-align: bottom;
  }

  // --- Element-specific display behavior ---

  // Line‑wrapping sync fix. Only apply to:
  // U+00A0 NO-BREAK SPACE
  // U+202F NARROW NO-BREAK SPACE

  space[data-character=" "],
  space[data-character=" "] {
    display: inline-block;
  }

  // For <break> and <shy>, a simple inline box is sufficient. Their purpose
  // is to mark a point in the text for a symbol, not to influence wrapping.
  break,
  shy {
    display: inline;
  }

  // Setup for the pseudo-elements that contain the visible symbols.
  break::before,
  space::before,
  shy::before {
    display: inline-block;
    position: absolute;
  }

  // Center the symbols inside their parent custom element.
  break::before {
    top: 50%;
    transform: translateY(-50%);
  }

  space::before,
  shy::before {
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  /* --- 6. Icon Font Mapping --- */

  // Assign content from the icon font's Private Use Area (PUA).
  p::after {
    content: "\e000";
  }
  p:last-child:after {
    content: "\e001";
  }
  break::before {
    content: "\e002";
  }
  shy::before {
    content: "\e003";
  }

  // Use the original character from the data-attribute. The custom font
  // will then map it to the correct symbol (e.g., centered dot for a space).
  space::before {
    content: attr(data-character);
  }
}
